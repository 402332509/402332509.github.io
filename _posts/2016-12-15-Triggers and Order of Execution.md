---
date: 2016-12-15 14:12:56
layout: post
title: 触发器和执行顺序
thread: 1002
categories: 日志
tags: Salesforce Apex
---


当你用insert,update或upset语句来保存一条记录时，Salesforce平台会按顺序执行下面的事件。

---

当Salesforce在服务器上执行这些事件之前，浏览器会执行JavaScript校验来判断是否有记录包含依赖字段。这个校验限制了每个依赖字段到它可获取的值。除此之外，客户端没有其他校验发生。

---

1. 在服务器端，Salesforce会：
2. 从数据库加载原始记录或从upsert语句中初始化记录。
 从请求中加载最新记录的字段值并重写旧值。
 如果请求来自于标准的编辑页面，Salesforce会	运行系统校验来检查记录：
 - 遵从布局指定的规则
 - 布局和字段定义上的必填项
 - 校验字段格式
 - 字段的最大长度
 当请求发自其他来源时，比如Apex应用或SOAP API调用， Salesforce只会校验外键。在执行触发器之前，Salesforce会检查自定义外键是否指向非当前对象。
 当多行项目被创建时（比如报价行项目和业务机会航项目），Salesforce会运行用户定义的验证规则。
3. 执行所有的before触发器。
4. 再次执行大部分系统校验步骤，比如校验必填字段是否有空值，并运行所有的用户定义的验证规则。Salesforce唯一不运行二次的系统校验是布局指定的规则。（当请求来自标准编辑页面时）
5. 执行重复检查。如果检查将记录识别为重复那么将会阻塞改动作，这条记录不会被保存也不会执行接下来的步骤，比如after触发器和工作流。
6. 保存记录到数据库，但暂时不会提交。
7. 执行所有的after触发器
8. 执行分配规则。
9. 执行自动响应规则。
10. 执行工作流。
11. 如果有工作流更新字段，会再次更新这条记录。
12. 如果记录是被工作流更新字段操作更新的，再次执行before update和after update触发器（只会再次执行一次），除了标准的校验之外。自定义验证规则，重复校验和升级规则不会再次运行。
13. 执行进程。
 如果有工作流触发器，执行流。
 The pilot program for flow trigger workflow actions is closed. 
 如果你在你的组织中已经启用了试点，你可以继续创建和编辑流触发工作流。如果你没有启用试点，你可以用进程生成器中的流操作来替代。
14. 执行升级规则
15. 执行投票规则
16. 如果记录包含有汇总字段或是跨对象工作流的一部分时，在父记录中计算并更新汇总字段。父记录会走保存流程。
17. 如果祖父记录更新了，并且祖父记录包含汇总字段或是跨对象工作流的一部分时，计算并更新祖父记录中的汇总字段。祖父记录会走保存流程。
18. 执行共享规则。
19. 提交所有DML操作到数据库。
20. 执行提交前逻辑，比如发邮件。

---

递归保存时，Salesforce会跳过第8步（分配规则）到17步（祖父记录中的汇总字段）

---

### 额外考虑


当你使用触发器时请注意一下几点。

* 当同一个对象因同一事件有多个触发器时，执行的顺序不能被保证。举个例子，如果你有两个before insert触发器在个案上，并且有一个新的个案记录插入时触发了这两个触发器，这两个触发器的触发顺序是不能被确定的。

* 当一个DML调用有部分成功时，若部分记录初始尝试结果报错，不止一个尝试能成功保存记录。举个例子，当一个记录在通过用户验证规则失败时会报错。触发器会在初次尝试时触发并在随后的尝试中再次触发。因为这些触发器调用是在同一事务中，我们通过触发器获取的静态类变量不会重置。DML调用允许部分成功，比如当你将数据库DML方法中的allOrOne参数设置为false时，或是当你用默认设置调用SOAP API时。详情请参见 [Bulk DML EXception Handling](https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_dml_bulk_exceptions.htm) 。

* 如果你的组织使用联系人关联多个客户，任何时候你插入一条非私有的联系人时，一条‘客户联系人关系’就会被创建，同样联系人记录被保存到数据库时，与之有关的的验证规则，数据库插入和触发器都会迅速被执行（第6步）。当你改变联系人的主要客户时，一条‘客户联系人关系’可能会被创建或编辑，并且‘客户联系人关系’的验证规则，数据库变动，触发器都会在联系人保存到数据库之后被迅速执行（第6步）。

* 如果你在使用before触发器来设置业务机会的阶段和预测类型(forecast category)时，具体行为如下：
	* 如果你设置阶段和预测类型时，业务机会记录会保留这些确定值。
	* 如果你设置阶段但不设置预测类型时，业务机会上的预测类型的值会默认关联到阶段的触发器上。
	* 如果你在API调用中或UI上重置阶段到一个指定值时，预测类型的值也会产生自API调用或UI。如果没有指定预测类型的值

* 如果你在克隆一个带产品的业务机会，下面的事件会按顺序触发：
	1. 父级业务机会根据上述的事件保存。
	2. 业务机会产品根据上述事件保存。
 
---

如果一个业务机会产品报错，你必须返回该业务机会并在克隆前修复这些错误。
如果有业务机会产品包含唯一的自定义字段，你必须在克隆该业务机会前将其置为空。

---

* `Trigger.old` 包含了触发了触发器的指定对象的上一版本。然而，有个异常。当一条一路更新并在随后触发了工作流字段更新， `Trigger.old` 在最近的一次更新触发器中不会在更新前立即包含该对象的上一版本，但该对象已经创建了。举个例子，假设一个存在的记录有一个数字类型字段并且初始默认值为1。一个用户将这个字段更新到10，一个工作流字段更新操作将这个字段增加到11。工作流更新后触发了update触发器，该对象的这个字段值从 `Trigger.old` 中拿到的值是1，而不是10，这是一个典型的案例。





---

 [原文链接](https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_triggers_order_of_execution.htm)
